<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Random Coffee Recipe (AeroPress + Pour-over)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 24px; line-height: 1.35; }
    .wrap { max-width: 920px; margin: 0 auto; }
    header { display: flex; gap: 12px; align-items: baseline; justify-content: space-between; flex-wrap: wrap; }
    h1 { font-size: 20px; margin: 0; }
    .sub { opacity: .75; font-size: 13px; margin-top: 6px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 16px; margin-top: 18px; }
    @media (min-width: 860px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 14px; padding: 16px; }
    .title { display:flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    h2 { font-size: 16px; margin: 0; }
    .pill { font-size: 12px; padding: 3px 10px; border: 1px solid rgba(127,127,127,.35); border-radius: 999px; opacity: .9; white-space: nowrap; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
    td { padding: 6px 0; vertical-align: top; }
    td:first-child { width: 46%; opacity: .8; }
    .steps { margin: 10px 0 0 0; padding-left: 18px; }
    .steps li { margin: 6px 0; }
    .actions { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 14px; }
    button { cursor: pointer; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); background: transparent; padding: 9px 12px; font-size: 14px; }
    button:hover { background: rgba(127,127,127,.12); }
    .tiny { font-size: 12px; opacity: .7; margin-top: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .timer-btn {
      margin-left: 8px;
      padding: 2px 8px;
      font-size: 11px;
      border-radius: 6px;
      background: rgba(127,127,127,.1);
      border: 1px solid rgba(127,127,127,.3);
      cursor: pointer;
      vertical-align: middle;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .timer-btn:hover { background: rgba(127,127,127,.2); }
    .timer-btn.running {
      background: #2563eb;
      color: white;
      border-color: #1d4ed8;
    }
    .timer-btn.finished {
      background: #059669;
      color: white;
      border-color: #047857;
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Random Coffee Recipe Generator</h1>
      <div class="sub">Reload the page for a new recipe. Uses Fellow Opus dial numbers.</div>
    </div>
    <div class="actions">
      <button id="regen" title="Generate without reloading">Generate new</button>
      <button id="copy" title="Copy to clipboard">Copy</button>
    </div>
  </header>

  <div class="grid">
    <section class="card" id="card"></section>
    <section class="card">
      <div class="title">
        <h2>Constraints & Notes</h2>
        <span class="pill">guardrails</span>
      </div>
      <ul class="steps">
        <li>Values are sampled uniformly within ranges.</li>
        <li>Pour-over total time is constrained to <span class="mono">2:00–5:30</span> (resampled if outside).</li>
        <li>AeroPress avoids extreme combos (too fine + high dose) by resampling if <span class="mono">Opus &lt; 5.0</span> and <span class="mono">dose &gt; 18g</span>.</li>
        <li>Ratio-driven: dose and ratio are picked first; water is computed.</li>
      </ul>
      <div class="tiny">Tip: If you want “more realistic” results, change sampling to triangular (center-weighted) in the JS.</div>
    </section>
  </div>

  <div class="tiny" id="seedline"></div>
</div>

<script>
  // -------- helpers --------
  const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
  const rand = (a, b) => a + Math.random() * (b - a);
  const rint = (a, b) => Math.round(rand(a, b));
  const rstep = (a, b, step) => Math.round(rand(a, b) / step) * step;
  const fmt1 = (x) => (Math.round(x * 10) / 10).toFixed(1);
  const fmt0 = (x) => String(Math.round(x));
  const mmss = (sec) => {
    sec = Math.round(sec);
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${String(s).padStart(2, "0")}`;
  };

  // -------- recipe generation --------
  function pickMethod() {
    return Math.random() < 0.5 ? "AeroPress" : "Pour-over";
  }

  function genAeropress() {
    // Ranges (from earlier: Aeropress: dose 12–20g; ratio 1:12–1:18; temp 80–96C; Opus 4.5–8.5; steep 45–180s; press 20–60s; stirs 0–20; swirls 0–3; bloom 0–30s; bypass 0–120g)
    let dose = rstep(12, 20, 0.5);
    let ratio = rstep(12, 18, 0.5);
    let water = Math.round(dose * ratio);

    let temp = rint(80, 96);
    let opus = rstep(4.5, 8.5, 0.1);
    let steep = rint(45, 180);
    let press = rint(20, 60);

    // Technique
    let method = Math.random() < 0.5 ? "standard" : "inverted";
    let bloomSec = rint(0, 30);
    let stirs = rint(0, 20);
    let swirls = rint(0, 3);
    let bypass = rstep(0, 120, 5);

    // Guardrail: avoid very fine + high dose
    if (opus < 5.0 && dose > 18) return genAeropress();

    const total = steep + press;
    const bloomWater = bloomSec > 0 ? Math.round(dose * rand(2.0, 3.0)) : 0;

    const steps = [];
    steps.push(`Heat water to ${temp}°C. Rinse filter.`);
    steps.push(`Add ${dose}g coffee (Opus ${fmt1(opus)}).`);
    if (bloomSec > 0) {
      steps.push({ text: `Bloom with ${bloomWater}g for ${bloomSec}s.`, duration: bloomSec });
    }
    steps.push(`Add remaining water to reach ${water}g total.`);
    if (stirs > 0) steps.push(`Stir ${stirs} times.`);
    if (swirls > 0) steps.push(`Swirl ${swirls} time(s).`);
    steps.push({ text: `Steep until ${mmss(steep)}.`, duration: steep });
    steps.push({ text: `Press for ${mmss(press)} (total contact ~${mmss(total)}).`, duration: press });
    if (bypass > 0) steps.push(`Optional: bypass/dilute with ${bypass}g hot water.`);

    return {
      methodName: "AeroPress",
      metaPill: method,
      fields: [
        ["Dose", `${fmt1(dose)} g`],
        ["Ratio", `1:${fmt1(ratio)}`],
        ["Water (brew)", `${water} g`],
        ["Temperature", `${temp} °C`],
        ["Grind (Fellow Opus)", fmt1(opus)],
        ["Steep", mmss(steep)],
        ["Press", mmss(press)],
        ["Bloom", bloomSec > 0 ? `${bloomSec}s (${bloomWater}g)` : "none"],
        ["Agitation", `stirs ${stirs}, swirls ${swirls}`],
        ["Bypass", bypass > 0 ? `${bypass} g` : "none"]
      ],
      steps
    };
  }

  function genPourover() {
    // Pour-over ranges: dose 12–22g; ratio 1:14–1:18; temp 88–99C; Opus 5.0–8.5
    // Bloom: 30–60s; bloom water 2.0–3.5x dose; pours 1–5; interval 20–60s; swirls 0–2
    // Total time constraint: 2:30–4:30 (we'll constrain to 2:00–5:30 as guardrail)
    let dose = rstep(12, 22, 0.5);
    let ratio = rstep(14, 18, 0.5);
    let water = Math.round(dose * ratio);

    let temp = rint(88, 99);
    let opus = rstep(5.0, 8.5, 0.1);

    let bloomSec = rint(30, 60);
    let bloomWater = Math.round(dose * rand(2.0, 3.5));
    let pours = rint(1, 5);
    let interval = pours > 1 ? rint(20, 60) : 0;
    let swirls = rint(0, 2);

    // Simple time model to keep outputs plausible:
    // totalTime ≈ bloom + (pours-1)*interval + drawdown
    // drawdown depends on grind/dose/water: coarser -> faster, larger water -> longer
    const grindFactor = (8.5 - opus) / (8.5 - 5.0); // finer => larger factor
    let drawdown = 90 + 90 * grindFactor + (water - 250) * 0.25 + (dose - 15) * 2;
    drawdown = clamp(drawdown, 60, 240);

    let total = bloomSec + (pours > 1 ? (pours - 1) * interval : 0) + drawdown;

    // Guardrail: constrain total time
    if (total < 120 || total > 330) return genPourover();

    // Pour schedule suggestion
    const remaining = Math.max(0, water - bloomWater);
    const pulses = pours;
    const pulseVol = pulses > 0 ? Math.round(remaining / pulses) : 0;

    const steps = [];
    steps.push(`Heat water to ${temp}°C. Rinse filter and preheat brewer.`);
    steps.push(`Add ${dose}g coffee (Opus ${fmt1(opus)}).`);
    steps.push({ text: `Bloom with ${bloomWater}g for ${bloomSec}s.`, duration: bloomSec });
    if (pours === 1) {
      steps.push(`Single continuous pour to ${water}g total.`);
    } else {
      steps.push({ text: `Do ${pours} pours of ~${pulseVol}g each (after bloom), every ${interval}s, to reach ${water}g total.`, duration: interval });
    }
    if (swirls > 0) steps.push(`Swirl ${swirls} time(s) after final pour.`);
    steps.push(`Target total brew time ~${mmss(total)}.`);

    return {
      methodName: "Pour-over",
      metaPill: "V60 / flat-bottom",
      fields: [
        ["Dose", `${fmt1(dose)} g`],
        ["Ratio", `1:${fmt1(ratio)}`],
        ["Water (total)", `${water} g`],
        ["Temperature", `${temp} °C`],
        ["Grind (Fellow Opus)", fmt1(opus)],
        ["Bloom", `${bloomSec}s (${bloomWater}g)`],
        ["Pours", `${pours}${pours > 1 ? ` (interval ${interval}s)` : " (continuous)"}`],
        ["Swirls", String(swirls)],
        ["Target total time", mmss(total)]
      ],
      steps
    };
  }

  function generate() {
    const method = pickMethod();
    return method === "AeroPress" ? genAeropress() : genPourover();
  }

  function render(recipe) {
    clearAllTimers();
    const card = document.getElementById("card");
    const rows = recipe.fields.map(([k, v]) => `<tr><td>${k}</td><td><strong>${v}</strong></td></tr>`).join("");
    const steps = recipe.steps.map(s => {
      const text = typeof s === "string" ? s : s.text;
      const duration = typeof s === "object" ? s.duration : null;
      const timerBtn = duration ? `<button class="timer-btn" data-duration="${duration}">Start ${mmss(duration)}</button>` : "";
      return `<li>${text}${timerBtn}</li>`;
    }).join("");

    card.innerHTML = `
      <div class="title">
        <h2>${recipe.methodName} recipe</h2>
        <span class="pill">${recipe.metaPill}</span>
      </div>
      <table>${rows}</table>
      <h3 style="font-size:14px;margin:14px 0 6px 0;opacity:.9;">Steps</h3>
      <ol class="steps">${steps}</ol>
      <div class="tiny">Reload to reroll. Button uses the same generator without reload.</div>
    `;

    // For copy
    const plain = [
      `${recipe.methodName} (${recipe.metaPill})`,
      ...recipe.fields.map(([k,v]) => `${k}: ${v}`),
      "",
      "Steps:",
      ...recipe.steps.map((s,i)=>{
        const text = typeof s === "string" ? s : s.text;
        return `${i+1}. ${text}`;
      })
    ].join("\n");
    card.dataset.plain = plain;
  }

  const activeTimers = new Map();

  function clearAllTimers() {
    for (const timer of activeTimers.values()) {
      clearInterval(timer.intervalId);
    }
    activeTimers.clear();
  }

  function handleTimerClick(btn) {
    if (activeTimers.has(btn)) {
      const timer = activeTimers.get(btn);
      clearInterval(timer.intervalId);
      activeTimers.delete(btn);
      btn.classList.remove("running", "finished");
      btn.textContent = `Start ${mmss(btn.dataset.duration)}`;
      return;
    }

    const duration = parseInt(btn.dataset.duration, 10);
    let remaining = duration;

    btn.classList.add("running");
    btn.classList.remove("finished");
    btn.textContent = mmss(remaining);

    const intervalId = setInterval(() => {
      remaining--;
      if (remaining <= 0) {
        clearInterval(intervalId);
        activeTimers.delete(btn);
        btn.classList.remove("running");
        btn.classList.add("finished");
        btn.textContent = "Done!";
        setTimeout(() => {
          if (!activeTimers.has(btn) && btn.classList.contains("finished")) {
            btn.classList.remove("finished");
            btn.textContent = `Start ${mmss(duration)}`;
          }
        }, 5000);
      } else {
        btn.textContent = mmss(remaining);
      }
    }, 1000);

    activeTimers.set(btn, { intervalId });
  }

  document.addEventListener("click", (e) => {
    if (e.target.classList.contains("timer-btn")) {
      handleTimerClick(e.target);
    }
  });

  // init on page load
  const recipe = generate();
  render(recipe);

  document.getElementById("regen").addEventListener("click", () => render(generate()));

  document.getElementById("copy").addEventListener("click", async () => {
    const txt = document.getElementById("card").dataset.plain || "";
    try {
      await navigator.clipboard.writeText(txt);
      const btn = document.getElementById("copy");
      const old = btn.textContent;
      btn.textContent = "Copied";
      setTimeout(() => (btn.textContent = old), 900);
    } catch {
      alert("Clipboard copy failed. Select and copy manually:\n\n" + txt);
    }
  });

  // lightweight “seed” line (not deterministic, just informational)
  document.getElementById("seedline").textContent =
    "Generated at " + new Date().toLocaleString() + " • Refresh for a new roll.";
</script>
</body>
</html>